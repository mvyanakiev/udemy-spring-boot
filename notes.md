https://github.com/in28minutes/spring-master-class
https://github.com/in28minutes/in28minutes-initiatives/blob/master/The-in28Minutes-TroubleshootingGuide-And-FAQ/quick-start.md

IOC container е всяко нещо, което имлементира Inversion of controll.
Application context e IOC container. Идеята е да вдигне и менажири всички бийнове. (Component, Repository, Service също са бийнове).

Имаш 3 въпроса които Спринг трябва да знае:
1. Кои са бийновете. (Component, Service, Repository и тия описани в Configuration с Bean).
2. Кои са депендънситата на бийновете (Autowired).
3. Къде да търси за бийнове (Component scan) @SpringBootApplication е началото на пакета за търсене, когато всичко е на едно място.

Като стратира апп-а първо прави компонент скан в пакиджите. Търси за класове с анотации.
Започва да съзадава бийновете и да идентифицира депендънситата.

Когато имаш 2 компонента от даден тип Спринг не знае кой да използва. @Primary му показва кой да вземе, иначе гърми.
Инджектнал си нещо с интерфейс без да укажеш коя имплементация използваш. т.е. Имаш 1 интерфейс (тип) и няколко имплементаци (компонента).
@Primary има по-висок приоритет. Дoри да си сложил интерфейса и написал иметo на конкретна имплементация, ако имаш @Primary на някоя от имплементациите ще вземе нея.

Другия вариант е вместо @Primary да използваш @Qualifier("име") и после като го инджектваш пак да добавиш @Qualifier("име").
И в двата случая трябва да пишеш допълнителни анотации. За това препоръката е да инджектваш с името на конкретната имплементация.

Като не си намери анотация за компонент а нещото е Autowired гърми със съобщение че не може да намери бийна.
(намира че нещо е в депендънси но не може да намери дадения бийн).

При грешки първо виж за правилната комбинация от @Component, @Autowired, @Primary

Освен конструктор инджекшън има и сетър инджекшън, което е дългото изписване на @Autowired.
Старо -> За всички задължителни депендънситата (без които класа не може да работи) да се използва конструктор инджекшън, за останалите @Autowired
Ново -> всичко е с @Autowired


AOP -> Aspect oriented programming.


#Scope
По дефолт прави един бийн и всеки път като ти потрябва ти го дава него (singelton)
Всеки път като поискаш получаваш нов бийн prototype -> @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)

Кохгато искаш да получиш прототип, но минаваш през сингълтън трябва да конфигурираш прокси.
Имаш ДАО което депендва на кънекшън.
ДАО-то е сингълтън, а кънекшъна прототип - ще получиш сингълтън.
Така плучаваш сингълтън ДАО и прототип кънекшън.
@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)

В Спринг сингълтън означава 1 инстанция за целия Application context, но може да има много в рамките на JVM.
В Java Design patterns (Gang of four) singelton означава 1 инстанция за цялата JVM.









